# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

## blendish python ripped from fro io_import_dxf

import string
import os
import bpy
import mathutils
from mathutils import Vector
import math
import copy

bl_info = {
    'name': 'Import Slic3r GCode - cyclic prints',
    'author': 'Lee Butler',
    'version': (0,1,0),
    'blender': (2, 7, 0),
    'location': 'File > Import-Export > Gcode',
    'description': 'Import and visualize gcode files generated by Slic3r (.gcode)',
    "wiki_url": "https://github.com/iraytrace/BlenderGcodeImport/wiki",
    "tracker_url": "",
    'category': 'Import-Export'}

__version__ = '.'.join([str(s) for s in bl_info['version']])

class IMPORT_OT_gcode(bpy.types.Operator):
    '''Imports Reprap FDM gcode'''
    bl_idname = "import_scene.gocde"
    bl_description = 'Gcode reader, reads tool moves and animates layer build'
    bl_label = "Import gcode" +' v.'+ __version__
    bl_space_type = "PROPERTIES"
    bl_region_type = "WINDOW"

    filepath = bpy.props.StringProperty(name="File Path", description="Filepath used for importing the GCode file", maxlen= 1024, default= "")

    def __init__(self):
        # current tool position
        self.pos = {'X':0.0, 'Y':0.0, 'Z':0.0, 'E':0.0}

        # set of accumulated points on current extrusion path
        # a set of points makes up a polyline
        self.points = []

        # set of polylines
        self.polys = []

        # each layer is a set of polylines at a constant Z
        self.layers = []

        # set of Z elevation changes.  Most common is layer height
        self.thickness = { }

        self.ySquash = 0.5
        self.xOoze = 0.4


    ##### DRAW #####
    def draw(self, context):
        layout0 = self.layout

    ##### EXECUTE #####
    def execute(self, context):
        print('execute')
        self.parse(self.filepath)
        return {'FINISHED'}

    ##### INVOKE  #####
    def invoke(self, context, event):
        print('invoke')
        wm = context.window_manager
        wm.fileselect_add(self)
        return {'RUNNING_MODAL'}

    ##### PARSE #####
    def parse(self, fileName):
        self.points = []

        #print ('---------- read ' + fileName + ' ------------')
        # get the object/curve names from the filename
        self.obName = fileName.split(os.sep)[-1]
        self.obName = self.obName.replace(".gcode", "")
        
        radius=0
        start = True
        
        # get print settings
        f = open(fileName)
        self.printSettings = ''
        for line in f.readlines():
            if(line[0:10] == ';SETTING_3'):
                self.printSettings+=line[11:-1]
            if(radius==0):
                layHi = line.split(';',1)[1].split(':')[0]
                if(layHi=='Layer height'):
                    radius=float(line.split(';',1)[1].split(':')[1])/10
        for strVar in self.printSettings.split('\\'):
            if(strVar[0:11] == 'nline_width'):
                self.xOoze = float(strVar.split('=')[1])
        f.close()
        
        # self.xOoze = self.xOoze*1.75
        
        self.xOoze = self.xOoze*14.5
        
        radius = 0
        
        f = open(fileName)
        for line in f.readlines():
            
            if(radius==0):
                layHi = line.split(';',1)[1].split(':')[0]
                if(layHi=='Layer height'):
                    radius=float(line.split(';',1)[1].split(':')[1])/10
                    
            if(start):
                if(line == ';TYPE:FILL\n'):
                    start = False
                continue
   
            if(line[0] == ';'):
                layerNew = line.split(';')[1].split(':')[0]
                if(layerNew=='LAYER'):
                    self.newLayer(radius)       
                    
            # remove comments and leading/trailing whitespace
            line = line.split(';', 1)[0].strip()

            # skip the blank lines
            if len(line) < 1:
                continue

            # tokenize the line
            tokens = line.split()

            self.dispatch(tokens)
        f.close()
        self.newLayer(-1.0)

        #print ('---------- build ------------')
        #print (' %d slices' % len(self.layers) )
        #print (' deltaZ values:')
        # count = 0
        # radius = 0
        # # find the most common inter-layer distance
        # for key in sorted(self.thickness.keys()):
        #        #print( '  %s : %d' % (key,self.thickness[key]) )
        #        if self.thickness[key] > count:
        #            count = self.thickness[key]
        #            radius = key
        # print(radius)
        
        profileNameFirst = self.obName + '_profileFirst'
        profileDataFirst = bpy.data.curves.new(profileNameFirst, type='CURVE')
        profileDataFirst.dimensions = '3D'
        
        profileNameMid = self.obName + '_profileMid'
        profileDataMid = bpy.data.curves.new(profileNameMid, type='CURVE')
        profileDataMid.dimensions = '3D'

        profileNameLast = self.obName + '_profileLast'
        profileDataLast = bpy.data.curves.new(profileNameLast, type='CURVE')
        profileDataLast.dimensions = '3D'

        profilePolyFirst = profileDataFirst.splines.new('NURBS')
        profilePolyMid1 = profileDataMid.splines.new('NURBS')
        profilePolyMid2 = profileDataMid.splines.new('NURBS')
        profilePolyLast = profileDataLast.splines.new('NURBS')
        
#        profilePoly.points.add(7)
        profilePolyFirst.points.add(9)
        profilePolyMid1.points.add(4)
        profilePolyMid2.points.add(4)
        profilePolyLast.points.add(9)
        angRad = radius * 0.70711
        
#        profilePolyFirst.points[0].co = (angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)       
#        profilePolyFirst.points[1].co = (radius * self.xOoze,  0.0,                 0.0, 1)
#        profilePolyFirst.points[2].co = (angRad* self.xOoze,  -radius* self.ySquash, 0.0, 1)
#        profilePolyFirst.points[3].co = (-angRad* self.xOoze, -radius* self.ySquash, 0.0, 1)
#        profilePolyFirst.points[4].co = (-radius* self.xOoze,  0.0,                  0.0, 1)
#        profilePolyFirst.points[5].co = (-angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)  
        
        profilePolyFirst.points[0].co = (angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyFirst.points[1].co = (radius* self.xOoze,  radius* self.ySquash, 0.0, 1)        
        profilePolyFirst.points[2].co = (radius * self.xOoze,  0.0,                 0.0, 1)
        profilePolyFirst.points[3].co = (radius* self.xOoze,  -radius* self.ySquash, 0.0, 1)   
        profilePolyFirst.points[4].co = (angRad* self.xOoze,  -radius* self.ySquash, 0.0, 1)
        profilePolyFirst.points[5].co = (-angRad* self.xOoze, -radius* self.ySquash, 0.0, 1)
        profilePolyFirst.points[6].co = (-radius* self.xOoze, -radius* self.ySquash, 0.0, 1)
        profilePolyFirst.points[7].co = (-radius* self.xOoze,  0.0,                  0.0, 1)
        profilePolyFirst.points[8].co = (-radius* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyFirst.points[9].co = (-angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)        
        
        profilePolyMid1.points[4].co = (angRad* self.xOoze,  -radius* self.ySquash, 0.0, 1)
        profilePolyMid1.points[3].co = (radius* self.xOoze,  -radius* self.ySquash, 0.0, 1)
        profilePolyMid1.points[2].co = (radius * self.xOoze,  0.0,                 0.0, 1)
        profilePolyMid1.points[1].co = (radius* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyMid1.points[0].co = (angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)
        
        profilePolyMid2.points[4].co = (-angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyMid2.points[3].co = (-radius* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyMid2.points[2].co = (-radius* self.xOoze,  0.0,                  0.0, 1)
        profilePolyMid2.points[1].co = (-radius* self.xOoze,  -radius* self.ySquash, 0.0, 1)   
        profilePolyMid2.points[0].co = (-angRad* self.xOoze,  -radius* self.ySquash, 0.0, 1)   
        
        profilePolyLast.points[9].co = (angRad* self.xOoze,  -radius* self.ySquash, 0.0, 1)
        profilePolyLast.points[8].co = (radius* self.xOoze,  -radius* self.ySquash, 0.0, 1)
        profilePolyLast.points[7].co = (radius * self.xOoze,  0.0,                 0.0, 1)
        profilePolyLast.points[6].co = (radius* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyLast.points[5].co = (angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyLast.points[4].co = (-angRad* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyLast.points[3].co = (-radius* self.xOoze,  radius* self.ySquash, 0.0, 1)
        profilePolyLast.points[2].co = (-radius* self.xOoze,  0.0,                  0.0, 1)
        profilePolyLast.points[1].co = (-radius* self.xOoze,  -radius* self.ySquash, 0.0, 1) 
        profilePolyLast.points[0].co = (-angRad* self.xOoze,  -radius* self.ySquash, 0.0, 1)        
        
        profilePolyFirst.use_cyclic_u = False
        profilePolyFirst.use_endpoint_u = True
        profilePolyFirst.order_u = 3
        profilePolyMid1.use_cyclic_u = False
        profilePolyMid1.use_endpoint_u = True
        profilePolyMid1.order_u = 3
        profilePolyMid2.use_cyclic_u = False
        profilePolyMid2.use_endpoint_u = True
        profilePolyMid2.order_u = 3
        profilePolyLast.use_cyclic_u = False
        profilePolyLast.use_endpoint_u = True
        profilePolyLast.order_u = 3
        
#        profilePolyFirst.resolution_v = 500
#        print (dir(profilePoly))
#        profilePolyFirst.type = 'BEZIER'
        profileObjectFirst = bpy.data.objects.new(profileNameFirst, profileDataFirst)
        profileObjectMid = bpy.data.objects.new(profileNameMid, profileDataMid)
        profileObjectLast = bpy.data.objects.new(profileNameLast, profileDataLast)

        scn = bpy.context.scene
        scn.objects.link(profileObjectFirst)
        scn.objects.link(profileObjectMid)
        scn.objects.link(profileObjectLast)
        


        for layerNum,layer in enumerate(self.layers):

            layerName = self.obName + '_slice_%d' % layerNum
            curveData = bpy.data.curves.new(layerName, type='CURVE')
            curveData.dimensions = '3D'
            # changed based on layer number
            if layerNum == 0:
                scn.objects.active = profileObjectFirst
                curveData.bevel_object = profileObjectFirst
                # print('first')
#                curveData.use_fill_caps = True
            elif layerNum == len(self.layers)-1:
                scn.objects.active = profileObjectLast
                curveData.bevel_object = profileObjectLast
                # print('last')
#                curveData.use_fill_caps = True
            else:
                scn.objects.active = profileObjectMid
                curveData.bevel_object = profileObjectMid
                # print('mid')
#                curveData.use_fill_caps = True
            #print (layerName + ':')

            for poly in layer:
                if(len(poly)>1):
                    pointNum = 0
                    polyline = curveData.splines.new('POLY')
                    polyline.points.add(len(poly)-1)
                    for point in poly:
                        x,y,z = point
                        newPt = mathutils.Vector((x,y,z,1))
                        polyline.points[pointNum].co = newPt
                        pointNum+=1
                    polyline.use_cyclic_u = True
#                    polyline.use_endpoint_u = True
#                    polyline.order_u = 2
#                polyline.points[len(poly)].co = secondPt
#                    if pointNum == 0:
#                        x,y,z = point
#                        oldPt = mathutils.Vector((x, y, z, 1))
#                        pointNum = 1
#                    else:
#                        polyline = curveData.splines.new('POLY')
#                        polyline.points.add(1)
#
#                        x,y,z = point
#                        newPt = mathutils.Vector((x, y, z, 1))
#                        polyline.points[0].co = oldPt
#                        polyline.points[1].co = newPt
#                        oldPt = newPt
            layerObject = bpy.data.objects.new(layerName, curveData)
            scn.objects.link(layerObject)
            scn.objects.active = layerObject


        # print('-------------- done -------------')




    ##### DISPATCH #####
    def dispatch(self, tokens):
        if tokens[0] in dir(self):
            eval('self.' + tokens[0] + '(' + str(tokens[1:]) + ')')
        else:
            print( 'unknown command:' + str(tokens[0]))

    ##### newPoly #####
    def newPoly(self):
        # stash points into curves
        # need to make this a copy
        if len(self.points) > 0:
            #print( 'poly with %d points' % (len(self.points)) )
            #for i,p in enumerate(self.points):
            #    print( '\t %d %s' % (i, str(p)) )
            self.polys.append( self.points[:] )
            self.points = []

    ##### newLayer #####
    def newLayer(self, delta):
        # stash existing points into curve
        self.newPoly()

        # stash existing set of polys into layer
        if len(self.polys) > 0:
            #print( 'new layer with %d polys' % len(self.polys) )
            self.layers.append( self.polys[:] )

            self.polys = []

            if delta > 0.0 and delta < 1.0:
                if delta in self.thickness.keys():
                    self.thickness[delta] = self.thickness[delta] + 1
                else:
                    self.thickness[delta] = 1

    ##### moveTo #####
    def moveTo(self, newPos):
        # if newPos['Z'] != self.pos['Z']:
        #     delta = newPos['Z'] - self.pos['Z']
        #     self.newLayer(delta)

        if newPos['E'] <= self.pos['E'] or newPos['E'] <= 0.0:
            self.newPoly()

        if newPos['E'] > 0 and newPos['E'] >= self.pos['E'] and newPos['X']>0:
            self.points.append([newPos['X'],
                            newPos['Y'],
                            newPos['Z']])

        # should this be an explicit copy?
        self.pos = copy.deepcopy(newPos)


    ###### parseCoords ######
    def parseCoords(self, tokens):
        npos = { }
        for tok in tokens:
            axis = tok[0]
            if axis in ['X', 'Y', 'Z', 'E']:
                npos[axis] = float(tok[1:])/10
        return npos

    ##### parseCoordsUpdate #####
    def parseCoordsUpdate(self, tokens):
        npos = self.parseCoords(tokens)

        for axis in ['X', 'Y', 'Z', 'E']:
            if axis not in npos.keys():
                npos[axis] = self.pos[axis]

        #print('coord: %8g %8g %8g  %g' % (npos['X'], npos['Y'], npos['Z'], npos['E']))
        return npos


    def N(self, tokens):
        '''line number and checksum'''
        # checksum not implemented
        self.dispatch(tokens[1:])

    def G0(self, tokens):
        '''move fast'''

        newPos = self.parseCoordsUpdate(tokens)
        self.moveTo(newPos)


    def G1(self, tokens):
        '''move to'''
        self.G0(tokens)

    def G21(self,tokens):
        '''set units mm'''
        pass

    def G28(self, tokens):
        '''move to origin'''

        npos = self.pos
        for tok in tokens:
           axis = tok[0]
           if axis in ['X', 'Y', 'Z', 'E']:
               # note that value is ignored
               npos[axis] = 0.0

        # no matter what we won't be extruding
        npos['E'] = 0.0
        self.moveTo(npos)

    def G90(self, tokens):
        '''set absolute positioning'''
        pass

    def G92(self, tokens):
        '''set position'''
        # fortunately Slic3r does not set arbitrary coordinates
        # or do relative positioning.  This is used just to zero
        # out the position on the extruder.

        newPos = self.parseCoordsUpdate(tokens)
        if newPos['E'] == 0:
            self.newPoly()

        self.pos = newPos

    def M82(self, tokens):
        '''set extruder absolute mode'''
        pass

    def M84(self, tokens):
        '''stop idle hold'''
        pass

    def M104(self,tokens):
        '''set extruder temperature'''
        pass

    def M106(self, tokens):
        '''fan on'''
        pass

    def M107(self,tokens):
        '''fan off'''
        pass

    def M109(self,tokens):
        '''set extruder temperature and wait'''
        pass




def menu_func(self, context):
    self.layout.operator(IMPORT_OT_gcode.bl_idname, text="Slic3r GCode cyclic(.gcode)", icon='PLUGIN')

def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_import.append(menu_func)

def unregister():
    bpy.utils.unregister_module(__name__)
    bpy.types.INFO_MT_file_import.remove(menu_func)


if __name__ == "__main__":
    register()
